***************************************************************************************************
**** DFS of Graph ( 01/08/23 ) ****

class Solution {
  public:
    // Function to return a list containing the DFS traversal of the graph.
    void dfs(vector<int> adj[],unordered_map<int,bool>& m,vector<int>& ans,int n){
        for(int i=0;i<adj[n].size();i++){
            if(m[adj[n][i]]==false){
                m[adj[n][i]]=true;
                ans.push_back(adj[n][i]);
                dfs(adj,m,ans,adj[n][i]);
            }
        }
    }
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        unordered_map<int,bool> m;
        vector<int> ans;
        for(int i=0;i<V;i++){
            if(m[i]==false){
                m[i]=true;
                ans.push_back(i);
                dfs(adj,m,ans,i);
            }
        }
        return ans;
    }
};

*******************************************************************************************
**** Shortest Source to Destination Path ( 02/08/23 ) ****

class Solution {
  public:
    int shortestDistance(int N, int M, vector<vector<int>> A, int x, int y) {
        if(A[0][0] == 0){
            return -1;
        }
        int ans = 70000;
       queue<pair<pair<int,int>,int>> q;
         vector<vector<int>> visited=A;
        for(int i=0;i<N;i++){
            for(int j=0;j<M;j++){
                visited[i][j]=0;
            }
        }
        visited[0][0] = 1;
        q.push({{0,0},0});
        pair<pair<int,int>,int> p;
        while(!q.empty()){
            p = q.front();
            if(p.first.first == x && p.first.second ==y){
                ans = p.second;
                break;
            }
            q.pop();
            
            //// right
            if(p.first.second+1 < M && visited[p.first.first][p.first.second+1]==0 && A[p.first.first][p.first.second+1]==1){
                visited[p.first.first][p.first.second+1] = 1;
                q.push({{p.first.first,p.first.second+1},p.second+1});
            }
            
            //// left
            if(p.first.second-1 >= 0 && visited[p.first.first][p.first.second-1]==0 && A[p.first.first][p.first.second-1]==1){
                visited[p.first.first][p.first.second-1] = 1;
                q.push({{p.first.first,p.first.second-1},p.second+1});
            }
            
            //// down
            if(p.first.first+1 < N && visited[p.first.first+1][p.first.second]==0 && A[p.first.first+1][p.first.second]==1){
                visited[p.first.first+1][p.first.second] = 1;
                q.push({{p.first.first+1,p.first.second},p.second+1});
            }
            
            //// up
            if(p.first.first-1 >= 0 && visited[p.first.first-1][p.first.second]==0 && A[p.first.first-1][p.first.second]==1){
                visited[p.first.first-1][p.first.second] = 1;
                q.push({{p.first.first-1,p.first.second},p.second+1});
            }
        }
        if(ans == 70000){
            return -1;
        }
        else{
            return ans;
        }
    }
};

************************************************************************************************************************
**** Shortest path in Directed Acyclic Graph ( 03/08/23 ) ****

class Solution {
  public:
  
  void solve2(unordered_map<int,vector<pair<int,int>>> m,stack<int>& st,vector<int>& ans){
      while(!st.empty()){
      int n = st.top();
      st.pop();
      for(int i=0;i<m[n].size();i++){
          if(ans[m[n][i].first] == -1 || ans[n]+m[n][i].second < ans[m[n][i].first]){
              ans[m[n][i].first] = ans[n]+m[n][i].second;
          }
      }
  }
  }
  
    void solve( unordered_map<int,vector<pair<int,int>>> m,stack<int>& st,unordered_map<int,bool>& visited,int n){
        for(int i=0;i<m[n].size();i++){
            if(visited[m[n][i].first] == false){
                visited[m[n][i].first] = true;
                solve(m,st,visited,m[n][i].first);
            }
        }
        st.push(n);
    }
  
     vector<int> shortestPath(int N,int M, vector<vector<int>>& edges){
         unordered_map<int,vector<pair<int,int>>> m;
         for(int i=0;i<M;i++){
             m[edges[i][0]].push_back({edges[i][1],edges[i][2]});
         }
        vector<int> ans;
        for(int i=0;i<N;i++){
            ans.push_back(-1);
        }
        ans[0] = 0;
        stack<int> st;
        unordered_map<int,bool> visited;
        visited[0] = true;
        solve(m,st,visited,0);
        solve2(m,st,ans);
        return ans;
    }
}; 

****************************************************************************************************
**** Reverse a Stack ( 04/08/23 ) ****

class Solution{
public:
    void Reverse(stack<int> &st){
        vector<int> v;
        while(!st.empty()){
            v.push_back(st.top());
            st.pop();
        }
        for(int i=0;i<v.size();i++){
            st.push(v[i]);
        }
    }
};

********************************************************************************************
**** Chocolate Distribution Problem ( 05/08/23 ) ****

class Solution{
    public:
    long long findMinDiff(vector<long long> a, long long n, long long m){
         sort(a.begin(),a.end());
         long long i=0,j=m-1,ans=INT_MAX;
         while(j<n){
             if(a[j] - a[i] < ans){
                 ans = a[j] - a[i];
             }
             i++; j++;
         }
         return ans;
    }   
};

******************************************************************************************
**** String Permutations ( 06/08/23 ) ****

class Solution{
    public:
    //Complete this function
    
    void solve(string s,string& str,vector<string>& ans){
        if(s.size() == 0){
            ans.push_back(str);
            return;
        }
        for(int i=0;i<s.size();i++){
            str.push_back(s[i]);
            solve(s.substr(0,i)+s.substr(i+1,s.size()-i-1),str,ans);
            str.pop_back();
        }
        
    }
    
    vector<string> permutation(string S)
    {
        vector<string> ans;
        string str = "";
        solve(S,str,ans);
        sort(ans.begin(),ans.end());
        return ans;
    }
};

***********************************************************************************
**** Largest prime factor ( 09/08/23 ) ****

class Solution{
public: 
    long long int largestPrimeFactor(int N){
        int ans = INT_MIN;
        for(int i=2;i<=sqrt(N);){
            while(N%i==0){
                N/=i;
                ans = max(ans,i);
            }
            i++;
        }
        return max(ans,N);
    }
};

***************************************************************
**** Nth Fibonacci Number ( 13/08/23 ) ****

class Solution {
  public:
  
  int solve(int n,vector<int>& v){
      if(v[n]!=-1){
          return v[n];
      }
      v[n] = (solve(n-1,v) + solve(n-2,v))%1000000007;
      return v[n];
  }
  
    int nthFibonacci(int n){
        vector<int> v(n+1,-1);
        v[0]=0;
        v[1]=1;
         return solve(n,v);
    }
};

*********************************************************************************
