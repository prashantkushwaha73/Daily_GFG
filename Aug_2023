***************************************************************************************************
**** DFS of Graph ( 01/08/23 ) ****

class Solution {
  public:
    // Function to return a list containing the DFS traversal of the graph.
    void dfs(vector<int> adj[],unordered_map<int,bool>& m,vector<int>& ans,int n){
        for(int i=0;i<adj[n].size();i++){
            if(m[adj[n][i]]==false){
                m[adj[n][i]]=true;
                ans.push_back(adj[n][i]);
                dfs(adj,m,ans,adj[n][i]);
            }
        }
    }
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        unordered_map<int,bool> m;
        vector<int> ans;
        for(int i=0;i<V;i++){
            if(m[i]==false){
                m[i]=true;
                ans.push_back(i);
                dfs(adj,m,ans,i);
            }
        }
        return ans;
    }
};

*******************************************************************************************
**** Shortest Source to Destination Path ( 02/08/23 ) ****

class Solution {
  public:
    int shortestDistance(int N, int M, vector<vector<int>> A, int x, int y) {
        if(A[0][0] == 0){
            return -1;
        }
        int ans = 70000;
       queue<pair<pair<int,int>,int>> q;
         vector<vector<int>> visited=A;
        for(int i=0;i<N;i++){
            for(int j=0;j<M;j++){
                visited[i][j]=0;
            }
        }
        visited[0][0] = 1;
        q.push({{0,0},0});
        pair<pair<int,int>,int> p;
        while(!q.empty()){
            p = q.front();
            if(p.first.first == x && p.first.second ==y){
                ans = p.second;
                break;
            }
            q.pop();
            
            //// right
            if(p.first.second+1 < M && visited[p.first.first][p.first.second+1]==0 && A[p.first.first][p.first.second+1]==1){
                visited[p.first.first][p.first.second+1] = 1;
                q.push({{p.first.first,p.first.second+1},p.second+1});
            }
            
            //// left
            if(p.first.second-1 >= 0 && visited[p.first.first][p.first.second-1]==0 && A[p.first.first][p.first.second-1]==1){
                visited[p.first.first][p.first.second-1] = 1;
                q.push({{p.first.first,p.first.second-1},p.second+1});
            }
            
            //// down
            if(p.first.first+1 < N && visited[p.first.first+1][p.first.second]==0 && A[p.first.first+1][p.first.second]==1){
                visited[p.first.first+1][p.first.second] = 1;
                q.push({{p.first.first+1,p.first.second},p.second+1});
            }
            
            //// up
            if(p.first.first-1 >= 0 && visited[p.first.first-1][p.first.second]==0 && A[p.first.first-1][p.first.second]==1){
                visited[p.first.first-1][p.first.second] = 1;
                q.push({{p.first.first-1,p.first.second},p.second+1});
            }
        }
        if(ans == 70000){
            return -1;
        }
        else{
            return ans;
        }
    }
};

************************************************************************************************************************
