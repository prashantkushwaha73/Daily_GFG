*******************************************************************************************************************************************************************************************
**** Make Binary Tree From Linked List ( 01/07/24 ) ****

void convert(Node *head, TreeNode *&root) {
    queue<TreeNode*> q;
    Node* temp = head;
    root = new TreeNode(temp->data);
    q.push(root); temp = temp->next;
    int n; TreeNode* neww;
    while(q.size()){
        n = q.size();
        for(int i=0;i<n;i++){
            if(temp){
                neww = new TreeNode(temp->data);
                q.front()->left = neww;
                temp = temp->next;
                q.push(neww);
            }
            if(temp){
                neww = new TreeNode(temp->data);
                q.front()->right = neww;
                temp = temp->next;
                q.push(neww);
            }
            else{
                return;
            }
            q.pop();
        }
    }
    return;
}

*******************************************************************************************************************************************************************************************************
**** linked list of strings forms a palindrome ( 02/07/24 ) ****

class Solution {
  public:
    bool compute(Node* head) {
        string str = "";
        while(head){
            str += head->data;
            head=head->next;
        }
        int i=0,j=str.size()-1;
        while(i<j){
            if(str[i]!=str[j]){
                return false;
            }
            i++; j--;
        }
        return true;
    }
};

*****************************************************************************************************************
**** Remove all occurences of duplicates in a linked list ( 03/07/24 ) ****

class Solution {
  public:
    Node* removeAllDuplicates(struct Node* head) {
        Node* ans = new Node(-1);
        Node* p = ans;
        int v=head->data,count=1;
        head = head->next;
        while(head){
            if(head->data == v){
                count++;
            }
            else{
                if(count==1){
                    Node* neww = new Node(v);
                    p->next = neww;
                    p = neww;
                    v=head->data;
                    count=1;
                }
                else{
                     v=head->data;
                    count=1;
                }
            }
            head=head->next;
        }
        if(count==1){
                    Node* neww = new Node(v);
                    p->next = neww;
                    p = neww;
                }
                return ans->next;
    }
};

***********************************************************************************************************************************************
