********************************************************************************************
**** Boundary traversal of matrix ( 01/10/23 ) ****

class Solution
{   
    public:
    //Function to return list of integers that form the boundary 
    //traversal of the matrix in a clockwise manner.
    vector<int> boundaryTraversal(vector<vector<int> > matrix, int n, int m) 
    {
        vector<int> ans;
        int i = 0;
        for(int j = 0;j<m;j++){
            ans.push_back(matrix[i][j]);
        }
        if(n==1){
            return ans;
        }
        int j = m-1;
        for(i=1;i<n;i++){
            ans.push_back(matrix[i][j]);
        }
        if(m==1){
            return ans;
        }
        i = n-1;
        for(j = m-2;j>=0;j--){
            ans.push_back(matrix[i][j]);
        }
        j = 0;
        for(i=n-2;i>0;i--){
            ans.push_back(matrix[i][j]);
        }
        return ans;
    }
}; 

********************************************************************************************************************
**** Column name from a given column number ( 03/10/23 ) ****

class Solution{
    public:
    string colName (long long int columnNumber)
    {
        long long int n;
        string ans="";
        vector<char> alpha={'A','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};
        while(columnNumber!=0){
            if(columnNumber<=26){
                ans = alpha[columnNumber] + ans;
                return ans;
            }
            n = columnNumber%26;
            if(n){
                ans = alpha[n] + ans;
                columnNumber /= 26;
            }
            else{
                ans = alpha[26] + ans;
                columnNumber /= 26;
                columnNumber -= 1;
            }
        }
        return ans;
    }
};

*************************************************************************************************
**** Roman Number to Integer ( 04/10/23 ) ****

class Solution {
  public:
    int romanToDecimal(string &str) {
        unordered_map<char,pair<int,int>> m;
        m['I']={1,1}; m['V']={5,2} ; m['X']= {10,3} ; m['L']={50,4}; m['C']={100,5}; m['D']={500,6}; m['M']={1000,7};
        reverse(str.begin(),str.end());
        int ans = 0;
        for(int i=0;i<str.size();i++){
            if(i<str.size()-1 && m[str[i]].second > m[str[i+1]].second){
                ans += (m[str[i]].first - m[str[i+1]].first);
                i++;
            }
            else{
            ans += m[str[i]].first;
            }
        }
        return ans;
    }
};

*****************************************************************************************
**** Pairwise swap elements of a linked list ( 07/10/23 ) ****

class Solution
{
    public:
    Node* pairWiseSwap(struct Node* head) 
    {
        if(head->next == NULL){
            return head;
        }
        Node* ans = head->next;
        Node* first = head;
        Node* second = head->next;
        Node* temp = second->next;
        second->next = first;
        first->next = temp;
        temp = first;
        first=first->next;
        if(first == NULL){
            return ans;
        }
        second = first->next;
        Node* pemp;
        while(second){
            pemp = second->next;
            temp->next = second;
            second->next = first;
            first->next = pemp;
            temp = first;
             first=first->next;
             if(first == NULL){
                 break;
             }
        second = first->next;
        }
        return ans;
    }
};

************************************************************************************
**** Insert in a Sorted List ( 10/08/23 ) ****

class Solution{
  public:
    // Should return head of the modified linked list
    Node *sortedInsert(struct Node* head, int data) {
        Node* temp = new Node(data);
        Node* trav = head;
        if(head->data >= data){
            temp->next = head;
            return temp;
        }
        while(1){
            if(trav->next){
                if(trav->next->data >= data){
                    temp->next = trav->next;
                    trav->next = temp;
                    return head;
                }
                else{
                    trav = trav->next;
                }
            }
            else{
                break;
            }
        }
        trav->next = temp;
        return head;
    }
};

**********************************************************************************************************
