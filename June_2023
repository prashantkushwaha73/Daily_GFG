****************************************************************************************************************
**** Topological sort ( 01/06/23 ) ****

 class Solution
{
    private:
    void dfs(vector<int> adj[],vector<int>& ans,map<int,bool>& mapp,int n){
        for(int j=0;j<adj[n].size();j++){
            if(mapp[adj[n][j]]==false){
                mapp[adj[n][j]]=true;
                dfs(adj,ans,mapp,adj[n][j]);
            }
        }
        ans.push_back(n);
        return;
    }
    
	public:
	//Function to return list containing vertices in Topological order. 
	vector<int> topoSort(int V, vector<int> adj[]) 
	{
	     vector<int> ans;
	    map<int,bool> mapp;
	    for(int i=0;i<V;i++){
	        if(mapp[i]==false){
	            mapp[i]=true;
	            dfs(adj,ans,mapp,i);
	        }
	    }
	    reverse(ans.begin(),ans.end());
	    return ans;
	}
};

*****************************************************************************************************************
**** Reversing the equation ( 04/06/23 ) ****

class Solution
{
  public:
    string reverseEqn (string s)
        {
            string ans="";
            stack<string> st;
            int i=0,j=0;
            while(i<s.size() && j<s.size()){
                if(s[j]=='+' || s[j]=='-' || s[j]=='*' || s[j]=='/'){
                    st.push(s.substr(i,(j-i)));
                    st.push(s.substr(j,1));
                    j++;
                    i=j;
                }
                else{
                    j++;
                }
            }
            st.push(s.substr(i,j-i));
            while(!st.empty()){
                ans+=st.top();
                st.pop();
            }
            return ans;
        }
};

********************************************************************************************************************
