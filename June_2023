****************************************************************************************************************
**** Topological sort ( 01/06/23 ) ****

 class Solution
{
    private:
    void dfs(vector<int> adj[],vector<int>& ans,map<int,bool>& mapp,int n){
        for(int j=0;j<adj[n].size();j++){
            if(mapp[adj[n][j]]==false){
                mapp[adj[n][j]]=true;
                dfs(adj,ans,mapp,adj[n][j]);
            }
        }
        ans.push_back(n);
        return;
    }
    
	public:
	//Function to return list containing vertices in Topological order. 
	vector<int> topoSort(int V, vector<int> adj[]) 
	{
	     vector<int> ans;
	    map<int,bool> mapp;
	    for(int i=0;i<V;i++){
	        if(mapp[i]==false){
	            mapp[i]=true;
	            dfs(adj,ans,mapp,i);
	        }
	    }
	    reverse(ans.begin(),ans.end());
	    return ans;
	}
};

*****************************************************************************************************************
**** Reversing the equation ( 04/06/23 ) ****

class Solution
{
  public:
    string reverseEqn (string s)
        {
            string ans="";
            stack<string> st;
            int i=0,j=0;
            while(i<s.size() && j<s.size()){
                if(s[j]=='+' || s[j]=='-' || s[j]=='*' || s[j]=='/'){
                    st.push(s.substr(i,(j-i)));
                    st.push(s.substr(j,1));
                    j++;
                    i=j;
                }
                else{
                    j++;
                }
            }
            st.push(s.substr(i,j-i));
            while(!st.empty()){
                ans+=st.top();
                st.pop();
            }
            return ans;
        }
};

********************************************************************************************************************
**** Find the Closest Element in BST ( 05/06/23 ) ****

class Solution
{
    public:
    //Function to find the least absolute difference between any node
	//value of the BST and the given integer.
	void solve(Node* root , int& ans , int K){
	    if(root==NULL){
	        return;
	    }
	    if(root->data == K){
	        ans=0;
	        return;
	    }
	    if(abs(root->data - K) < ans){
	        ans=abs(root->data - K);
	    }
	    if(root->data > K){
	        solve(root->left,ans,K);
	    }
	    else{
	        solve(root->right,ans,K);
	    }
	}
	
    int minDiff(Node *root, int K)
    {
        int ans=abs(root->data - K);
        solve(root,ans,K);
        return ans;
    }
};

*******************************************************************************************************************
