****************************************************************************************************************
**** Topological sort ( 01/06/23 ) ****

 class Solution
{
    private:
    void dfs(vector<int> adj[],vector<int>& ans,map<int,bool>& mapp,int n){
        for(int j=0;j<adj[n].size();j++){
            if(mapp[adj[n][j]]==false){
                mapp[adj[n][j]]=true;
                dfs(adj,ans,mapp,adj[n][j]);
            }
        }
        ans.push_back(n);
        return;
    }
    
	public:
	//Function to return list containing vertices in Topological order. 
	vector<int> topoSort(int V, vector<int> adj[]) 
	{
	     vector<int> ans;
	    map<int,bool> mapp;
	    for(int i=0;i<V;i++){
	        if(mapp[i]==false){
	            mapp[i]=true;
	            dfs(adj,ans,mapp,i);
	        }
	    }
	    reverse(ans.begin(),ans.end());
	    return ans;
	}
};

*****************************************************************************************************************
**** Reversing the equation ( 04/06/23 ) ****

class Solution
{
  public:
    string reverseEqn (string s)
        {
            string ans="";
            stack<string> st;
            int i=0,j=0;
            while(i<s.size() && j<s.size()){
                if(s[j]=='+' || s[j]=='-' || s[j]=='*' || s[j]=='/'){
                    st.push(s.substr(i,(j-i)));
                    st.push(s.substr(j,1));
                    j++;
                    i=j;
                }
                else{
                    j++;
                }
            }
            st.push(s.substr(i,j-i));
            while(!st.empty()){
                ans+=st.top();
                st.pop();
            }
            return ans;
        }
};

********************************************************************************************************************
**** Find the Closest Element in BST ( 05/06/23 ) ****

class Solution
{
    public:
    //Function to find the least absolute difference between any node
	//value of the BST and the given integer.
	void solve(Node* root , int& ans , int K){
	    if(root==NULL){
	        return;
	    }
	    if(root->data == K){
	        ans=0;
	        return;
	    }
	    if(abs(root->data - K) < ans){
	        ans=abs(root->data - K);
	    }
	    if(root->data > K){
	        solve(root->left,ans,K);
	    }
	    else{
	        solve(root->right,ans,K);
	    }
	}
	
    int minDiff(Node *root, int K)
    {
        int ans=abs(root->data - K);
        solve(root,ans,K);
        return ans;
    }
};

*******************************************************************************************************************
**** Predecessor and Successor ( 06/06/23 ) ****

class Solution
{
    public:
    void solve(Node* root,Node*& pre,Node*& suc,int key,bool& check,bool& r,bool& ra){
        if(check){
            return;
        }
        if(r){
            suc = root;
            check = true;
            return;
        }
        
        if(root == NULL){
            return;
        }
        solve(root->left,pre,suc,key,check,r,ra);
        if(check){
            return;
        }
        if(ra){
            suc = root;
            check = true;
            return;
        }
        
        if(root->key == key){
            if(root->right){
                ra = true;
                solve(root->right,pre,suc,key,check,r,ra);
                return;
            }
            r = true;
            return;
        }
        
        else if(root->key > key){
            suc = root;
            check = true;
            return;
        }
        else{
            pre = root;
            solve(root->right,pre,suc,key,check,r,ra);
            return;
        }
        return;
    }
    
    void findPreSuc(Node* root, Node*& pre, Node*& suc, int key)
    {
        bool check = false,r=false,ra=false;
        solve(root,pre,suc,key,check,r,ra);
        return;
    }
};

**************************************************************************************************************************
**** Least Prime Factor ( 07/06/23 ) ****

class Solution {
  public:
  bool isPrime(int n)
{
    // Corner case
    if (n <= 1)
        return false;
 
    // Check from 2 to n-1
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            return false;
 
    return true;
}

int iPrime(int n)
{
    // Corner case
    
    // Check from 2 to n-1
    for (int i = 2; i <= sqrt(n); i++){
        if (n % i == 0)
            return i;
    }
    
}
    
    vector<int> leastPrimeFactor(int n) {
        vector<int> ans ;
        ans.push_back(0); ans.push_back(1); ans.push_back(2);
        for(int i=3;i<=n;i++){
           if(isPrime(i)){
               ans.push_back(i);
           }
           else{
               ans.push_back(iPrime(i));
           }
        }
        return ans;
    }
};

****************************************************************************************************************************
